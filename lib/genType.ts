import { Mustache } from "./types";

const uniq = <T>(arr: T[]): T[] => Array.from(new Set(arr));
const OPTIONAL = "__OPTIONAL__";
type Obj = Record<string, string[] | Record<string, any>>;

/* 
given an array of keys like

["user", "emails", "address"]

this will return an object like

{ user: { emails: { address: ["string"] } } }

*/
export const nestedObj = (
  keys: string[],
  typeToSet: string[] = ["string", "boolean", "number"]
): Obj => {
  const obj: Obj = {};
  if (keys.length === 0) {
    return obj;
  }
  const key = keys[0];
  if (!obj[key]) {
    obj[key] = keys.length === 1 ? [...typeToSet] : nestedObj(keys.slice(1));
  } else if (Array.isArray(obj[key])) {
    if (keys.length === 1) {
      obj[key] = uniq([...obj[key], ...typeToSet]);
    } else {
      obj[key] = [...obj[key], nestedObj(keys.slice(1))];
    }
  } else if (typeof obj[key] === "object") {
    obj[key] = nestedObj(keys.slice(1));
  }
  return obj;
};

/*
smartly merge two objects generated by nestedObj together
*/
export const mergeObj = (obj1: Obj, obj2: Obj): Obj => {
  const keys = uniq([...Object.keys(obj1), ...Object.keys(obj2)]);
  const newObj: Obj = {};
  keys.forEach((key) => {
    if (obj1[key] && obj2[key]) {
      if (Array.isArray(obj1[key]) && Array.isArray(obj2[key])) {
        newObj[key] = uniq([...obj1[key], ...obj2[key]]);
      } else if (
        typeof obj1[key] === "object" &&
        typeof obj2[key] === "object"
      ) {
        newObj[key] = mergeObj(obj1[key] as Obj, obj2[key] as Obj);
      } else if (Array.isArray(obj1[key])) {
        newObj[key] = [...obj1[key], obj2[key]];
      } else if (Array.isArray(obj2[key])) {
        newObj[key] = [...obj2[key], obj1[key]];
      }
    } else if (obj1[key]) {
      newObj[key] = obj1[key];
    } else if (obj2[key]) {
      newObj[key] = obj2[key];
    }
  });
  return newObj;
};

// render a single object to a TypeScript type
export const renderObj = (obj: Obj, level: number = 1): string => {
  const inner = Object.entries(obj)
    .map(([_key, value]) => {
      let key = _key;
      let optStr = "";
      if (key.startsWith(OPTIONAL)) {
        key = key.replace(OPTIONAL, "");
        optStr = "?";
      }
      if (Array.isArray(value)) {
        return `${"  ".repeat(level)}${key}${optStr}: ${renderValue(
          value,
          level
        )};`;
      }
      return `${"  ".repeat(level)}${key}${optStr}: ${renderObj(
        value,
        level + 1
      )};`;
    })
    .join("\n");
  return `{\n${inner}\n${"  ".repeat(level - 1)}}`;
};

const renderValue = (value: any, level: number): string => {
  if (Array.isArray(value)) {
    return value.map((v) => renderValue(v, level)).join(" | ");
  } else if (typeof value === "object") {
    return renderObj(value, level + 1);
  } else if (typeof value === "string") {
    return value;
  }
  return `can't render ${value}`;
};

const deepSet = (obj: Obj, keys: string[], value: any): void => {
  let current = obj;
  keys.forEach((key, i) => {
    if (i === keys.length - 1) {
      if (value === OPTIONAL) {
        current[`${OPTIONAL}${key}`] = current[key];
        delete current[key];
      } else if (Array.isArray(current[key])) {
        current[key] = uniq([...current[key], value]);
      } else if (typeof current[key] === "object") {
        current[key] = [current[key], value];
      } else {
        current[key] = value;
      }
    } else {
      if (!current[key]) {
        current[key] = {};
      }
      if (Array.isArray(current[key])) {
        current[key].forEach((v: any) => {
          deepSet(v, keys.slice(i + 1), value);
        });
      } else if (typeof current[key] === "object") {
        current = current[key];
      }
    }
  });
};

// generate a TypeScript type from a parsed Mustache template
export const genType = (parsed: Mustache[]): string => {
  let obj: Obj = {};

  parsed.forEach((content: Mustache) => {
    if (content.type === "text") {
      return null;
    }
    if (content.type === "variable") {
      obj = mergeObj(obj, nestedObj(content.name));
    }
    if (content.type === "section") {
      const nestedVars = content.content
        .filter((c) => c.type === "variable")
        .map((c) => c.name);
      if (nestedVars.length === 0) {
        obj = mergeObj(obj, nestedObj(content.name, ["boolean"]));
      }
      nestedVars.forEach((vars) => {
        obj = mergeObj(obj, nestedObj([...content.name, ...vars]));
        // object or boolean
        deepSet(obj, [...content.name], ["boolean"]);
        // make nested var optional
        deepSet(obj, [...content.name, ...vars], OPTIONAL);

        // handle top level vars
        obj = mergeObj(obj, nestedObj([...vars]));
        // make top level vars optional
        deepSet(obj, [...vars], OPTIONAL);
      });
    }
    if (content.type === "inverted") {
      obj = mergeObj(obj, nestedObj(content.name));
    }
    if (content.type === "comment") {
      return null;
    }
    if (content.type === "partial") {
      return null;
    }
    return null;
  });

  return renderObj(obj);
};
